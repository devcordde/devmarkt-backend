type Query {
    templates: [Template!] @Auth(role: "user")

    template(
        name: TemplateName!
    ): TemplateResponse @Auth(role: "user")

    roles: [String!] @Auth(role: "admin")

    user(
        id: UserIdInput! # TODO: Refactor this to a string representation
    ): UserResponse @Auth(role: "admin")
}

type Mutation {
    createTemplate(
        name: TemplateName!
        questions: [QuestionInput!]!
    ): TemplateResponse @Auth(role: "admin")

    # TODO: adjust the implementation to 'disable' instead of delete it from the database
    # TODO: rename this query due to the new functionality
    deleteTemplate(
        name: TemplateName!
    ): Boolean @Auth(role: "admin")

    # TODO: merge the next 4 queries in a single 'editTemplate' query
    updateTemplateName(
        oldName: TemplateName!
        newName: TemplateName!
    ): Boolean @Auth(role: "admin")

    addQuestion(
        templateName: TemplateName!
        question: QuestionAddInput!
    ): QuestionResponse @Auth(role: "admin")

    updateQuestion(
        templateName: TemplateName!
        question: QuestionInput!
    ): QuestionResponse @Auth(role: "admin")

    deleteQuestion(
        templateName: TemplateName!
        number: PositiveInt!
    ): Boolean @Auth(role: "admin")

    createUser(
        userId: UserIdInput! # TODO: Use string representation
        roles: [String!]! # TODO: use enum for roles
    ): UserResponse @Auth(role: "admin")

    deleteUser(
        userId: UserIdInput! # TODO: Use string representation
    ): Boolean! @Auth(role: "admin")

    #
    addUserRoles(
        userId: UserIdInput! # TODO: Use string representation
        roles: [String!]! # TODO: use enum for roles
    ): UserResponse @Auth(role: "admin")

    removeUserRoles(
        userId: UserIdInput! # TODO: Use string representation
        roles: [String!]!  # TODO: use enum for roles
    ): UserResponse @Auth(role: "admin")
}

# common
type Failure {
    message: String!
    errorCode: String!
}
